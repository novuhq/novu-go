// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/novuhq/novu-go/v3/internal/utils"
)

// Channels - Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
type Channels struct {
	// Email channel specific overrides
	Email *EmailChannelOverrides `json:"email,omitempty"`
}

func (c *Channels) GetEmail() *EmailChannelOverrides {
	if c == nil {
		return nil
	}
	return c.Email
}

// Overrides - This could be used to override provider specific configurations
type Overrides struct {
	// This could be used to override provider specific configurations or layout at the step level
	Steps map[string]StepsOverrides `json:"steps,omitempty"`
	// Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
	Channels *Channels `json:"channels,omitempty"`
	// Overrides the provider configuration for the entire workflow and all steps
	Providers map[string]map[string]any `json:"providers,omitempty"`
	// Override the email provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Email map[string]any `json:"email,omitempty"`
	// Override the push provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Push map[string]any `json:"push,omitempty"`
	// Override the sms provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Sms map[string]any `json:"sms,omitempty"`
	// Override the chat provider specific configurations for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Chat map[string]any `json:"chat,omitempty"`
	// Override the layout identifier for the entire workflow
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	LayoutIdentifier *string `json:"layoutIdentifier,omitempty"`
	// Severity of the workflow
	Severity *SeverityLevelEnum `json:"severity,omitempty"`
}

func (o *Overrides) GetSteps() map[string]StepsOverrides {
	if o == nil {
		return nil
	}
	return o.Steps
}

func (o *Overrides) GetChannels() *Channels {
	if o == nil {
		return nil
	}
	return o.Channels
}

func (o *Overrides) GetProviders() map[string]map[string]any {
	if o == nil {
		return nil
	}
	return o.Providers
}

func (o *Overrides) GetEmail() map[string]any {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *Overrides) GetPush() map[string]any {
	if o == nil {
		return nil
	}
	return o.Push
}

func (o *Overrides) GetSms() map[string]any {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (o *Overrides) GetChat() map[string]any {
	if o == nil {
		return nil
	}
	return o.Chat
}

func (o *Overrides) GetLayoutIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.LayoutIdentifier
}

func (o *Overrides) GetSeverity() *SeverityLevelEnum {
	if o == nil {
		return nil
	}
	return o.Severity
}

type To1Type string

const (
	To1TypeSubscriberPayloadDto To1Type = "SubscriberPayloadDto"
	To1TypeTopicPayloadDto      To1Type = "TopicPayloadDto"
	To1TypeStr                  To1Type = "str"
)

type To1 struct {
	SubscriberPayloadDto *SubscriberPayloadDto `queryParam:"inline,name=one"`
	TopicPayloadDto      *TopicPayloadDto      `queryParam:"inline,name=one"`
	Str                  *string               `queryParam:"inline,name=one"`

	Type To1Type
}

func CreateTo1SubscriberPayloadDto(subscriberPayloadDto SubscriberPayloadDto) To1 {
	typ := To1TypeSubscriberPayloadDto

	return To1{
		SubscriberPayloadDto: &subscriberPayloadDto,
		Type:                 typ,
	}
}

func CreateTo1TopicPayloadDto(topicPayloadDto TopicPayloadDto) To1 {
	typ := To1TypeTopicPayloadDto

	return To1{
		TopicPayloadDto: &topicPayloadDto,
		Type:            typ,
	}
}

func CreateTo1Str(str string) To1 {
	typ := To1TypeStr

	return To1{
		Str:  &str,
		Type: typ,
	}
}

func (u *To1) UnmarshalJSON(data []byte) error {

	var topicPayloadDto TopicPayloadDto = TopicPayloadDto{}
	if err := utils.UnmarshalJSON(data, &topicPayloadDto, "", true, nil); err == nil {
		u.TopicPayloadDto = &topicPayloadDto
		u.Type = To1TypeTopicPayloadDto
		return nil
	}

	var subscriberPayloadDto SubscriberPayloadDto = SubscriberPayloadDto{}
	if err := utils.UnmarshalJSON(data, &subscriberPayloadDto, "", true, nil); err == nil {
		u.SubscriberPayloadDto = &subscriberPayloadDto
		u.Type = To1TypeSubscriberPayloadDto
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = To1TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for To1", string(data))
}

func (u To1) MarshalJSON() ([]byte, error) {
	if u.SubscriberPayloadDto != nil {
		return utils.MarshalJSON(u.SubscriberPayloadDto, "", true)
	}

	if u.TopicPayloadDto != nil {
		return utils.MarshalJSON(u.TopicPayloadDto, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type To1: all fields are null")
}

type ToType string

const (
	ToTypeArrayOfTo1           ToType = "arrayOfTo1"
	ToTypeStr                  ToType = "str"
	ToTypeSubscriberPayloadDto ToType = "SubscriberPayloadDto"
	ToTypeTopicPayloadDto      ToType = "TopicPayloadDto"
)

// To - The recipients list of people who will receive the notification.
type To struct {
	ArrayOfTo1           []To1                 `queryParam:"inline,name=to"`
	Str                  *string               `queryParam:"inline,name=to"`
	SubscriberPayloadDto *SubscriberPayloadDto `queryParam:"inline,name=to"`
	TopicPayloadDto      *TopicPayloadDto      `queryParam:"inline,name=to"`

	Type ToType
}

func CreateToArrayOfTo1(arrayOfTo1 []To1) To {
	typ := ToTypeArrayOfTo1

	return To{
		ArrayOfTo1: arrayOfTo1,
		Type:       typ,
	}
}

func CreateToStr(str string) To {
	typ := ToTypeStr

	return To{
		Str:  &str,
		Type: typ,
	}
}

func CreateToSubscriberPayloadDto(subscriberPayloadDto SubscriberPayloadDto) To {
	typ := ToTypeSubscriberPayloadDto

	return To{
		SubscriberPayloadDto: &subscriberPayloadDto,
		Type:                 typ,
	}
}

func CreateToTopicPayloadDto(topicPayloadDto TopicPayloadDto) To {
	typ := ToTypeTopicPayloadDto

	return To{
		TopicPayloadDto: &topicPayloadDto,
		Type:            typ,
	}
}

func (u *To) UnmarshalJSON(data []byte) error {

	var topicPayloadDto TopicPayloadDto = TopicPayloadDto{}
	if err := utils.UnmarshalJSON(data, &topicPayloadDto, "", true, nil); err == nil {
		u.TopicPayloadDto = &topicPayloadDto
		u.Type = ToTypeTopicPayloadDto
		return nil
	}

	var subscriberPayloadDto SubscriberPayloadDto = SubscriberPayloadDto{}
	if err := utils.UnmarshalJSON(data, &subscriberPayloadDto, "", true, nil); err == nil {
		u.SubscriberPayloadDto = &subscriberPayloadDto
		u.Type = ToTypeSubscriberPayloadDto
		return nil
	}

	var arrayOfTo1 []To1 = []To1{}
	if err := utils.UnmarshalJSON(data, &arrayOfTo1, "", true, nil); err == nil {
		u.ArrayOfTo1 = arrayOfTo1
		u.Type = ToTypeArrayOfTo1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ToTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for To", string(data))
}

func (u To) MarshalJSON() ([]byte, error) {
	if u.ArrayOfTo1 != nil {
		return utils.MarshalJSON(u.ArrayOfTo1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.SubscriberPayloadDto != nil {
		return utils.MarshalJSON(u.SubscriberPayloadDto, "", true)
	}

	if u.TopicPayloadDto != nil {
		return utils.MarshalJSON(u.TopicPayloadDto, "", true)
	}

	return nil, errors.New("could not marshal union type To: all fields are null")
}

type ActorType string

const (
	ActorTypeStr                  ActorType = "str"
	ActorTypeSubscriberPayloadDto ActorType = "SubscriberPayloadDto"
)

// Actor - It is used to display the Avatar of the provided actor's subscriber id or actor object.
//
//	If a new actor object is provided, we will create a new subscriber in our system
type Actor struct {
	Str                  *string               `queryParam:"inline,name=actor"`
	SubscriberPayloadDto *SubscriberPayloadDto `queryParam:"inline,name=actor"`

	Type ActorType
}

func CreateActorStr(str string) Actor {
	typ := ActorTypeStr

	return Actor{
		Str:  &str,
		Type: typ,
	}
}

func CreateActorSubscriberPayloadDto(subscriberPayloadDto SubscriberPayloadDto) Actor {
	typ := ActorTypeSubscriberPayloadDto

	return Actor{
		SubscriberPayloadDto: &subscriberPayloadDto,
		Type:                 typ,
	}
}

func (u *Actor) UnmarshalJSON(data []byte) error {

	var subscriberPayloadDto SubscriberPayloadDto = SubscriberPayloadDto{}
	if err := utils.UnmarshalJSON(data, &subscriberPayloadDto, "", true, nil); err == nil {
		u.SubscriberPayloadDto = &subscriberPayloadDto
		u.Type = ActorTypeSubscriberPayloadDto
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ActorTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Actor", string(data))
}

func (u Actor) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.SubscriberPayloadDto != nil {
		return utils.MarshalJSON(u.SubscriberPayloadDto, "", true)
	}

	return nil, errors.New("could not marshal union type Actor: all fields are null")
}

type TenantType string

const (
	TenantTypeStr              TenantType = "str"
	TenantTypeTenantPayloadDto TenantType = "TenantPayloadDto"
)

// Tenant - It is used to specify a tenant context during trigger event.
//
//	Existing tenants will be updated with the provided details.
type Tenant struct {
	Str              *string           `queryParam:"inline,name=tenant"`
	TenantPayloadDto *TenantPayloadDto `queryParam:"inline,name=tenant"`

	Type TenantType
}

func CreateTenantStr(str string) Tenant {
	typ := TenantTypeStr

	return Tenant{
		Str:  &str,
		Type: typ,
	}
}

func CreateTenantTenantPayloadDto(tenantPayloadDto TenantPayloadDto) Tenant {
	typ := TenantTypeTenantPayloadDto

	return Tenant{
		TenantPayloadDto: &tenantPayloadDto,
		Type:             typ,
	}
}

func (u *Tenant) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = TenantTypeStr
		return nil
	}

	var tenantPayloadDto TenantPayloadDto = TenantPayloadDto{}
	if err := utils.UnmarshalJSON(data, &tenantPayloadDto, "", true, nil); err == nil {
		u.TenantPayloadDto = &tenantPayloadDto
		u.Type = TenantTypeTenantPayloadDto
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Tenant", string(data))
}

func (u Tenant) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.TenantPayloadDto != nil {
		return utils.MarshalJSON(u.TenantPayloadDto, "", true)
	}

	return nil, errors.New("could not marshal union type Tenant: all fields are null")
}

// Two - Rich context object with id and optional data
type Two struct {
	ID string `json:"id"`
	// Optional additional context data
	Data map[string]any `json:"data,omitempty"`
}

func (t Two) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Two) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (t *Two) GetID() string {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *Two) GetData() map[string]any {
	if t == nil {
		return nil
	}
	return t.Data
}

type ContextType string

const (
	ContextTypeStr ContextType = "str"
	ContextTypeTwo ContextType = "2"
)

type Context struct {
	Str *string `queryParam:"inline,name=context"`
	Two *Two    `queryParam:"inline,name=context"`

	Type ContextType
}

func CreateContextStr(str string) Context {
	typ := ContextTypeStr

	return Context{
		Str:  &str,
		Type: typ,
	}
}

func CreateContextTwo(two Two) Context {
	typ := ContextTypeTwo

	return Context{
		Two:  &two,
		Type: typ,
	}
}

func (u *Context) UnmarshalJSON(data []byte) error {

	var two Two = Two{}
	if err := utils.UnmarshalJSON(data, &two, "", true, nil); err == nil {
		u.Two = &two
		u.Type = ContextTypeTwo
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ContextTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Context", string(data))
}

func (u Context) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Two != nil {
		return utils.MarshalJSON(u.Two, "", true)
	}

	return nil, errors.New("could not marshal union type Context: all fields are null")
}

type TriggerEventRequestDto struct {
	// The trigger identifier of the workflow you wish to send. This identifier can be found on the workflow page.
	WorkflowID string `json:"name"`
	// The payload object is used to pass additional custom information that could be
	//     used to render the workflow, or perform routing rules based on it.
	//       This data will also be available when fetching the notifications feed from the API to display certain parts of the UI.
	Payload map[string]any `json:"payload,omitempty"`
	// This could be used to override provider specific configurations
	Overrides *Overrides `json:"overrides,omitempty"`
	// The recipients list of people who will receive the notification.
	To To `json:"to"`
	// A unique identifier for deduplication. If the same **transactionId** is sent again,
	//       the trigger is ignored. Useful to prevent duplicate notifications. The retention period depends on your billing tier.
	TransactionID *string `json:"transactionId,omitempty"`
	// It is used to display the Avatar of the provided actor's subscriber id or actor object.
	//     If a new actor object is provided, we will create a new subscriber in our system
	Actor *Actor `json:"actor,omitempty"`
	// It is used to specify a tenant context during trigger event.
	//     Existing tenants will be updated with the provided details.
	Tenant  *Tenant            `json:"tenant,omitempty"`
	Context map[string]Context `json:"context,omitempty"`
}

func (t *TriggerEventRequestDto) GetWorkflowID() string {
	if t == nil {
		return ""
	}
	return t.WorkflowID
}

func (t *TriggerEventRequestDto) GetPayload() map[string]any {
	if t == nil {
		return nil
	}
	return t.Payload
}

func (t *TriggerEventRequestDto) GetOverrides() *Overrides {
	if t == nil {
		return nil
	}
	return t.Overrides
}

func (t *TriggerEventRequestDto) GetTo() To {
	if t == nil {
		return To{}
	}
	return t.To
}

func (t *TriggerEventRequestDto) GetTransactionID() *string {
	if t == nil {
		return nil
	}
	return t.TransactionID
}

func (t *TriggerEventRequestDto) GetActor() *Actor {
	if t == nil {
		return nil
	}
	return t.Actor
}

func (t *TriggerEventRequestDto) GetTenant() *Tenant {
	if t == nil {
		return nil
	}
	return t.Tenant
}

func (t *TriggerEventRequestDto) GetContext() map[string]Context {
	if t == nil {
		return nil
	}
	return t.Context
}
